<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chi·∫øn Sƒ© Kh√°ng Chi·∫øn - T∆∞ T∆∞·ªüng H·ªì Ch√≠ Minh</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(45deg, #2c3e50, #34495e, #27ae60);
            background-size: 400% 400%;
            animation: battlefieldMove 15s ease infinite;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }
        @keyframes battlefieldMove {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0.1) 0%, rgba(0,0,0,0.3) 100%);
        }
        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            gap: 12px;
        }
        .stat-panel {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            border: 2px solid #e74c3c;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        .health-bar, .spirit-bar {
            width: 200px;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            margin: 5px 0;
            overflow: hidden;
            border: 1px solid #fff;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        .spirit-fill {
            height: 100%;
            background: linear-gradient(90deg, #f1c40f, #f39c12);
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        .battlefield {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle at 20% 20%, rgba(46, 125, 50, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(139, 69, 19, 0.3) 0%, transparent 50%);
        }
        .player {
            position: absolute;
            width: 50px;
            height: 50px;
            font-size: 40px;
            transition: none;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.3));
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .enemy {
            position: absolute;
            width: 40px;
            height: 40px;
            font-size: 35px;
            z-index: 50;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            filter: drop-shadow(0 0 8px rgba(255,0,0,0.5));
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .bullet {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #ffff00, #ff6b00);
            border-radius: 50%;
            z-index: 75;
            box-shadow: 0 0 10px #ffff00;
        }
        .enemy-bullet {
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #ff0000, #8b0000);
            border-radius: 50%;
            z-index: 75;
            box-shadow: 0 0 8px #ff0000;
        }
        .explosion {
            position: absolute;
            font-size: 60px;
            z-index: 200;
            animation: explode 0.5s ease-out forwards;
            pointer-events: none;
        }
        @keyframes explode {
            0% { transform: scale(0.1); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
        .question-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            color: white;
            padding: 30px;
            border-radius: 20px;
            border: 3px solid #e74c3c;
            z-index: 2000;
            max-width: 600px;
            width: 90%;
            backdrop-filter: blur(15px);
        }
        .question-text {
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
            color: #ecf0f1;
        }
        .answer-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        .answer-btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .answer-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4); }
        .answer-btn.correct { background: linear-gradient(45deg, #27ae60, #2ecc71); }
        .answer-btn.incorrect { background: linear-gradient(45deg, #e74c3c, #c0392b); }
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
            pointer-events: none;
        }
        .wave-indicator {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em; color: #e74c3c; font-weight: bold;
            z-index: 1500; text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            animation: waveAnnounce 2s ease-out forwards;
            pointer-events: none;
        }
        @keyframes waveAnnounce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        .game-over-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center;
            z-index: 3000; backdrop-filter: blur(15px);
        }
        .game-over-content {
            text-align: center; color: white; background: rgba(231, 76, 60, 0.2);
            padding: 40px; border-radius: 20px; border: 3px solid #e74c3c;
        }
        .restart-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white; border: none; padding: 15px 30px; border-radius: 25px;
            font-size: 1.1em; cursor: pointer; margin-top: 20px; transition: all 0.3s ease;
        }
        .explanation { margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px; display: none; }
        /* N√∫t √¢m thanh */
        #toggle-sound { pointer-events: auto; cursor: pointer; padding: 8px 14px; border-radius: 10px; border: 1px solid #fff; background: #2ecc71; color: #fff; }
        #volume { pointer-events: auto; cursor: pointer; }
    </style>
</head>
<body>
<div class="game-container">
    <div class="hud">
        <div class="stat-panel">
            <div>üáªüá≥ Chi·∫øn Sƒ© Kh√°ng Chi·∫øn</div>
            <div class="health-bar"><div class="health-fill" id="health-bar"></div></div>
            <div>M√°u: <span id="health-text">100</span></div>
        </div>

        <div style="text-align: center; color: white; font-size: 1.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
            <div>üèÜ ƒêi·ªÉm: <span id="score">0</span></div>
            <div>‚ö° L√†n: <span id="wave">1</span></div>
        </div>

        <div class="stat-panel">
            <div>üí™ Tinh Th·∫ßn C√°ch M·∫°ng</div>
            <div class="spirit-bar"><div class="spirit-fill" id="spirit-bar"></div></div>
            <div>NƒÉng l∆∞·ª£ng: <span id="spirit-text">100</span></div>
        </div>

        <!-- B·∫£ng ƒëi·ªÅu khi·ªÉn √¢m thanh -->
        <div class="stat-panel" style="display:flex;align-items:center;gap:10px;">
            <button id="toggle-sound">üîä Enable Sound</button>
            <div style="color:#fff;">Vol</div>
            <input id="volume" type="range" min="0" max="1" step="0.01" value="0.6">
        </div>
    </div>

    <div class="battlefield" id="battlefield">
        <div class="player" id="player">ü™ñ</div>
    </div>

    <div class="instructions">
        <strong>ƒêi·ªÅu khi·ªÉn:</strong><br>
        ‚å®Ô∏è WASD ho·∫∑c ‚Üê‚Üí‚Üë‚Üì: Di chuy·ªÉn<br>
        üñ±Ô∏è Click chu·ªôt: B·∫Øn ƒë·∫°n<br>
        üí° Tr·∫£ l·ªùi ƒë√∫ng c√¢u h·ªèi ƒë·ªÉ ƒë∆∞·ª£c buff!
    </div>

    <div class="question-popup" id="question-popup" style="display: none;">
        <div class="question-text" id="question-text"></div>
        <div class="answer-options" id="answer-options"></div>
        <div class="explanation" id="explanation"></div>
    </div>

    <div class="game-over-screen" id="game-over">
        <div class="game-over-content">
            <h1>üáªüá≥ K·∫øt Th√∫c Nhi·ªám V·ª•! üáªüá≥</h1>
            <div style="font-size: 1.5em; margin: 20px 0;">
                ƒêi·ªÉm cu·ªëi: <span id="final-score">0</span><br>
                L√†n ƒë·∫°t ƒë∆∞·ª£c: <span id="final-wave">1</span>
            </div>
            <p>B·∫°n ƒë√£ chi·∫øn ƒë·∫•u d≈©ng c·∫£m v√¨ t∆∞ t∆∞·ªüng H·ªì Ch√≠ Minh!</p>
            <button class="restart-btn" onclick="restartGame()">üîÑ Chi·∫øn ƒê·∫•u L·∫°i</button>
        </div>
    </div>
</div>

<script>
/* ====================== Sound Manager (Web Audio API) ====================== */
class SoundManager {
  constructor() {
    this.ctx = null;
    this.master = null;
    this.enabled = false;
    this.volume = 0.6;
    this._bgmTimer = null;
  }
  init() {
    if (this.enabled) return;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) return;
    this.ctx = new AudioContext();
    this.master = this.ctx.createGain();
    this.master.gain.value = this.volume;
    this.master.connect(this.ctx.destination);
    this.enabled = true;
    if (this.ctx.state === "suspended") this.ctx.resume();
  }
  setVolume(v) {
    this.volume = v;
    if (this.master) this.master.gain.value = v;
  }
  _tone({ freq=440, type="square", dur=0.08, attack=0.002, decay=0.06, vol=0.8 }) {
    if (!this.enabled) return;
    const t0 = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    gain.gain.setValueAtTime(0, t0);
    gain.gain.linearRampToValueAtTime(vol, t0 + attack);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + attack + decay);
    osc.connect(gain).connect(this.master);
    osc.start(t0);
    osc.stop(t0 + attack + decay + 0.02);
  }
  _noise({ dur=0.25, vol=0.5, lp=1200 }) {
    if (!this.enabled) return;
    const t0 = this.ctx.currentTime;
    const bufferSize = Math.floor(this.ctx.sampleRate * dur);
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.9;
    const src = this.ctx.createBufferSource();
    src.buffer = buffer;
    const filter = this.ctx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = lp;
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(vol, t0);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    src.connect(filter).connect(gain).connect(this.master);
    src.start(t0);
    src.stop(t0 + dur + 0.02);
  }
  shoot() {
    this._tone({ freq: 900, dur: 0.05, type: "square", vol: 0.5 });
    setTimeout(() => this._tone({ freq: 1500, dur: 0.04, type: "square", vol: 0.4 }), 30);
  }
  explosion() {
    this._noise({ dur: 0.22, vol: 0.6, lp: 1400 });
    setTimeout(() => this._tone({ freq: 80, type: "sine", dur: 0.2, attack: 0.005, decay: 0.22, vol: 0.5 }), 10);
  }
  popup() { this._tone({ freq: 600, dur: 0.06, type: "triangle", vol: 0.35 }); }
  correct() {
    [880, 1175, 1480].forEach((f, i) => setTimeout(() => this._tone({ freq: f, type: "sine", dur: 0.08, vol: 0.5 }), i * 90));
  }
  incorrect() {
    [300, 220, 160].forEach((f, i) => setTimeout(() => this._tone({ freq: f, type: "sawtooth", dur: 0.09, vol: 0.5 }), i * 70));
  }
  gameover() {
    [440, 330, 220, 150].forEach((f, i) => setTimeout(() => this._tone({ freq: f, type: "triangle", dur: 0.18, vol: 0.6 }), i * 160));
  }
  startBGM() {
    if (!this.enabled || this._bgmTimer) return;
    const pattern = [523, 587, 659, 523, 523, 587, 659, 698]; // C D E C | C D E F
    let idx = 0;
    this._bgmTimer = setInterval(() => {
      this._tone({ freq: pattern[idx % pattern.length], type: "sine", dur: 0.12, vol: 0.25 });
      idx++;
    }, 320);
  }
  stopBGM() {
    if (this._bgmTimer) { clearInterval(this._bgmTimer); this._bgmTimer = null; }
  }
}
const SND = new SoundManager();
/* ========================================================================== */

// Game variables
let player = { x: 400, y: 500, health: 100, spirit: 100 };
let enemies = [];
let bullets = [];
let enemyBullets = [];
let score = 0;
let wave = 1;
let gameRunning = true;
let questionActive = false;
let keys = {};
let lastEnemySpawn = 0;
let currentQuestionIndex = 0;

// ==== Sound UI binding ====
const btnSound = document.getElementById('toggle-sound');
const volSlider = document.getElementById('volume');

function enableSoundOnce() {
  if (!SND.enabled) {
    SND.init();
    SND.startBGM();
    if (btnSound) {
      btnSound.textContent = 'üîá Mute';
      btnSound.style.background = '#e67e22';
    }
  }
}
if (btnSound) {
  btnSound.addEventListener('click', () => {
    if (!SND.enabled) {
      enableSoundOnce();
    } else {
      if (SND.master.gain.value > 0) {
        SND.setVolume(0);
        btnSound.textContent = 'üîä Unmute';
        btnSound.style.background = '#2ecc71';
      } else {
        const v = parseFloat(volSlider?.value || '0.6');
        SND.setVolume(v);
        btnSound.textContent = 'üîá Mute';
        btnSound.style.background = '#e67e22';
      }
    }
  });
}
if (volSlider) {
  volSlider.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    if (SND.enabled) SND.setVolume(v);
  });
}
['keydown','mousedown','touchstart'].forEach(evt => {
  window.addEventListener(evt, () => enableSoundOnce(), { once: true });
});

// Questions
const questions = [
  {
    question: "Theo t∆∞ t∆∞·ªüng H·ªì Ch√≠ Minh, ƒëi·ªÅu g√¨ l√† s·ª©c m·∫°nh c·ªßa nh√¢n d√¢n trong kh√°ng chi·∫øn?",
    answers: ["V≈© kh√≠ t·ªët", "ƒêo√†n k·∫øt m·ªôt l√≤ng", "S·ªë l∆∞·ª£ng ƒë√¥ng", "Chi·∫øn thu·∫≠t hay"],
    correct: 1,
    explanation: "H·ªì Ch√≠ Minh lu√¥n nh·∫•n m·∫°nh 'ƒêo√†n k·∫øt, ƒëo√†n k·∫øt, ƒë·∫°i ƒëo√†n k·∫øt' l√† s·ª©c m·∫°nh v√¥ ƒë·ªãch."
  },
  {
    question: "Ph∆∞∆°ng ch√¢m kh√°ng chi·∫øn c·ªßa H·ªì Ch√≠ Minh l√† g√¨?",
    answers: ["Nhanh chi·∫øn nhanh th·∫Øng", "To√†n d√¢n, to√†n di·ªán, tr∆∞·ªùng k·ª≥", "Ch·ªâ d·ª±a v√†o qu√¢n ƒë·ªôi", "T·∫•n c√¥ng th·∫≥ng"],
    correct: 1,
    explanation: "Kh√°ng chi·∫øn 'to√†n d√¢n, to√†n di·ªán, tr∆∞·ªùng k·ª≥' l√† chi·∫øn l∆∞·ª£c ƒë√∫ng ƒë·∫Øn c·ªßa B√°c H·ªì."
  },
  {
    question: "T∆∞ t∆∞·ªüng n√†o c·ªßa H·ªì Ch√≠ Minh v·ªÅ x√¢y d·ª±ng con ng∆∞·ªùi?",
    answers: ["Con ng∆∞·ªùi l√† m√°y m√≥c", "Con ng∆∞·ªùi l√† y·∫øu t·ªë quy·∫øt ƒë·ªãnh", "Ch·ªâ c·∫ßn t√†i nƒÉng", "Ch·ªâ c·∫ßn ƒë·ª©c t√≠nh"],
    correct: 1,
    explanation: "B√°c H·ªì lu√¥n coi con ng∆∞·ªùi l√† y·∫øu t·ªë quy·∫øt ƒë·ªãnh m·ªçi th√†nh c√¥ng c·ªßa c√°ch m·∫°ng."
  },
  {
    question: "H·ªì Ch√≠ Minh n√≥i: 'Kh√¥ng c√≥ g√¨ qu√Ω h∆°n...'?",
    answers: ["H√≤a b√¨nh", "ƒê·ªôc l·∫≠p t·ª± do", "ƒêo√†n k·∫øt", "Th√†nh c√¥ng"],
    correct: 1,
    explanation: "'Kh√¥ng c√≥ g√¨ qu√Ω h∆°n ƒë·ªôc l·∫≠p t·ª± do' - c√¢u n√≥i b·∫•t h·ªß c·ªßa Ch·ªß t·ªãch H·ªì Ch√≠ Minh."
  },
  {
    question: "Quan ƒëi·ªÉm c·ªßa H·ªì Ch√≠ Minh v·ªÅ ƒë·∫°o ƒë·ª©c c√°ch m·∫°ng?",
    answers: ["Kh√¥ng quan tr·ªçng", "Quan tr·ªçng ngang t√†i nƒÉng", "Ch·ªâ d√†nh cho l√£nh ƒë·∫°o", "ƒê·ª©c tr∆∞·ªõc, t√†i sau"],
    correct: 3,
    explanation: "'ƒê·ª©c tr∆∞·ªõc, t√†i sau' - ƒë·∫°o ƒë·ª©c l√† g·ªëc, t√†i nƒÉng l√† ng·ªçn trong t∆∞ t∆∞·ªüng H·ªì Ch√≠ Minh."
  }
];

const enemyTypes = ["üè∞", "‚öîÔ∏è", "üõ°Ô∏è", "üëë", "üè¥‚Äç‚ò†Ô∏è"];

// Event listeners
document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
document.addEventListener('keyup',   (e) => { keys[e.key.toLowerCase()] = false; });
document.addEventListener('click', (e) => {
  if (!questionActive && gameRunning) {
    shootBullet(e.clientX, e.clientY);
    SND.shoot(); // √¢m b·∫Øn
  }
});

// Initialize game
function initGame() {
  player.x = window.innerWidth / 2 - 25;
  player.y = window.innerHeight - 100;
  updatePlayerPosition();
  updateUI();
  setInterval(spawnEnemy, 2000);
  gameLoop();
}

function updatePlayerPosition() {
  const playerEl = document.getElementById('player');
  playerEl.style.left = player.x + 'px';
  playerEl.style.top  = player.y + 'px';
}

function updateUI() {
  document.getElementById('health-text').textContent = Math.max(0, player.health);
  document.getElementById('spirit-text').textContent = Math.max(0, player.spirit);
  document.getElementById('score').textContent = score;
  document.getElementById('wave').textContent = wave;
  document.getElementById('health-bar').style.width = Math.max(0, player.health) + '%';
  document.getElementById('spirit-bar').style.width = Math.max(0, player.spirit) + '%';
}

function handlePlayerMovement() {
  if (!gameRunning || questionActive) return;
  const speed = 5;
  if (keys['w'] || keys['arrowup'])    player.y = Math.max(0, player.y - speed);
  if (keys['s'] || keys['arrowdown'])  player.y = Math.min(window.innerHeight - 50, player.y + speed);
  if (keys['a'] || keys['arrowleft'])  player.x = Math.max(0, player.x - speed);
  if (keys['d'] || keys['arrowright']) player.x = Math.min(window.innerWidth - 50, player.x + speed);
  updatePlayerPosition();
}

function spawnEnemy() {
  if (!gameRunning || questionActive) return;
  const enemy = {
    id: Date.now() + Math.random(),
    x: Math.random() * (window.innerWidth - 40),
    y: -40,
    health: 1,
    type: enemyTypes[Math.floor(Math.random() * enemyTypes.length)],
    lastShot: 0
  };
  enemies.push(enemy);
  const enemyEl = document.createElement('div');
  enemyEl.className = 'enemy';
  enemyEl.id = 'enemy_' + enemy.id;
  enemyEl.textContent = enemy.type;
  enemyEl.style.left = enemy.x + 'px';
  enemyEl.style.top  = enemy.y + 'px';
  document.getElementById('battlefield').appendChild(enemyEl);
}

function updateEnemies() {
  enemies.forEach((enemy, index) => {
    enemy.y += 2;
    const enemyEl = document.getElementById('enemy_' + enemy.id);
    if (enemyEl) enemyEl.style.top = enemy.y + 'px';

    if (enemy.y > window.innerHeight) {
      removeEnemy(index);
      player.health -= 10;
    }

    if (Date.now() - enemy.lastShot > 3000 && Math.random() < 0.02) {
      shootEnemyBullet(enemy.x + 20, enemy.y + 20);
      enemy.lastShot = Date.now();
    }

    if (Math.abs(enemy.x - player.x) < 40 && Math.abs(enemy.y - player.y) < 40) {
      removeEnemy(index);
      player.health -= 20;
      createExplosion(enemy.x, enemy.y);
    }
  });
}

function shootBullet(targetX, targetY) {
  if (player.spirit < 5) return;
  player.spirit -= 5;
  const dx = targetX - (player.x + 25);
  const dy = targetY - (player.y + 25);
  const distance = Math.sqrt(dx * dx + dy * dy);
  const bullet = {
    id: Date.now() + Math.random(),
    x: player.x + 25,
    y: player.y + 25,
    vx: (dx / distance) * 8,
    vy: (dy / distance) * 8
  };
  bullets.push(bullet);
  const bulletEl = document.createElement('div');
  bulletEl.className = 'bullet';
  bulletEl.id = 'bullet_' + bullet.id;
  bulletEl.style.left = bullet.x + 'px';
  bulletEl.style.top  = bullet.y + 'px';
  document.getElementById('battlefield').appendChild(bulletEl);
}

function shootEnemyBullet(x, y) {
  const dx = player.x - x;
  const dy = player.y - y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const bullet = {
    id: Date.now() + Math.random(),
    x: x, y: y,
    vx: (dx / distance) * 3,
    vy: (dy / distance) * 3
  };
  enemyBullets.push(bullet);
  const bulletEl = document.createElement('div');
  bulletEl.className = 'enemy-bullet';
  bulletEl.id = 'enemybullet_' + bullet.id;
  bulletEl.style.left = bullet.x + 'px';
  bulletEl.style.top  = bullet.y + 'px';
  document.getElementById('battlefield').appendChild(bulletEl);

  // √¢m thanh b·∫Øn c·ªßa ƒë·ªãch (nh·∫π)
  SND._tone({ freq: 400, type: 'square', dur: 0.04, vol: 0.25 });
}

function updateBullets() {
  // Player bullets
  bullets.forEach((bullet, bulletIndex) => {
    bullet.x += bullet.vx;
    bullet.y += bullet.vy;
    const bulletEl = document.getElementById('bullet_' + bullet.id);
    if (bulletEl) {
      bulletEl.style.left = bullet.x + 'px';
      bulletEl.style.top  = bullet.y + 'px';
    }
    enemies.forEach((enemy, enemyIndex) => {
      if (Math.abs(bullet.x - enemy.x - 20) < 20 &&
          Math.abs(bullet.y - enemy.y - 20) < 20) {
        enemy.health--;
        removeBullet(bulletIndex);
        createExplosion(enemy.x, enemy.y);
        if (enemy.health <= 0) {
          removeEnemy(enemyIndex);
          score += 10;
          if (Math.random() < 0.3) showQuestion();
        }
      }
    });
    if (bullet.x < 0 || bullet.x > window.innerWidth ||
        bullet.y < 0 || bullet.y > window.innerHeight) {
      removeBullet(bulletIndex);
    }
  });

  // Enemy bullets
  enemyBullets.forEach((bullet, bulletIndex) => {
    bullet.x += bullet.vx;
    bullet.y += bullet.vy;
    const bulletEl = document.getElementById('enemybullet_' + bullet.id);
    if (bulletEl) {
      bulletEl.style.left = bullet.x + 'px';
      bulletEl.style.top  = bullet.y + 'px';
    }
    if (Math.abs(bullet.x - player.x - 25) < 25 &&
        Math.abs(bullet.y - player.y - 25) < 25) {
      removeEnemyBullet(bulletIndex);
      player.health -= 15;
      createExplosion(player.x, player.y);
    }
    if (bullet.x < 0 || bullet.x > window.innerWidth ||
        bullet.y < 0 || bullet.y > window.innerHeight) {
      removeEnemyBullet(bulletIndex);
    }
  });
}

function removeBullet(index) {
  if (bullets[index]) {
    const bulletEl = document.getElementById('bullet_' + bullets[index].id);
    if (bulletEl) bulletEl.remove();
    bullets.splice(index, 1);
  }
}
function removeEnemyBullet(index) {
  if (enemyBullets[index]) {
    const bulletEl = document.getElementById('enemybullet_' + enemyBullets[index].id);
    if (bulletEl) bulletEl.remove();
    enemyBullets.splice(index, 1);
  }
}
function removeEnemy(index) {
  if (enemies[index]) {
    const enemyEl = document.getElementById('enemy_' + enemies[index].id);
    if (enemyEl) enemyEl.remove();
    enemies.splice(index, 1);
  }
}

function createExplosion(x, y) {
  // √¢m thanh n·ªï
  SND.explosion();

  const explosion = document.createElement('div');
  explosion.className = 'explosion';
  explosion.textContent = 'üí•';
  explosion.style.left = x + 'px';
  explosion.style.top  = y + 'px';
  document.getElementById('battlefield').appendChild(explosion);
  setTimeout(() => { if (explosion.parentNode) explosion.remove(); }, 500);
}

function showQuestion() {
  // √¢m popup
  SND.popup();

  if (currentQuestionIndex >= questions.length) currentQuestionIndex = 0;
  questionActive = true;
  const question = questions[currentQuestionIndex];
  document.getElementById('question-text').textContent = question.question;
  const optionsContainer = document.getElementById('answer-options');
  optionsContainer.innerHTML = '';
  question.answers.forEach((answer, index) => {
    const button = document.createElement('button');
    button.className = 'answer-btn';
    button.textContent = answer;
    button.onclick = () => selectAnswer(index);
    optionsContainer.appendChild(button);
  });
  document.getElementById('explanation').style.display = 'none';
  document.getElementById('question-popup').style.display = 'block';
}

function selectAnswer(selectedIndex) {
  const question = questions[currentQuestionIndex];
  const buttons = document.querySelectorAll('.answer-btn');
  buttons.forEach(btn => btn.disabled = true);

  if (selectedIndex === question.correct) {
    buttons[selectedIndex].classList.add('correct');
    player.health = Math.min(100, player.health + 20);
    player.spirit = Math.min(100, player.spirit + 30);
    score += 50;
    SND.correct(); // √¢m ƒë√∫ng
  } else {
    buttons[selectedIndex].classList.add('incorrect');
    buttons[question.correct].classList.add('correct');
    SND.incorrect(); // √¢m sai
  }

  document.getElementById('explanation').textContent = question.explanation;
  document.getElementById('explanation').style.display = 'block';

  setTimeout(() => {
    document.getElementById('question-popup').style.display = 'none';
    questionActive = false;
    currentQuestionIndex++;
  }, 3000);
}

function checkGameOver() {
  if (player.health <= 0) {
    gameRunning = false;
    document.getElementById('final-score').textContent = score;
    document.getElementById('final-wave').textContent = wave;
    document.getElementById('game-over').style.display = 'flex';
    SND.gameover();
    SND.stopBGM();
  }
}

function restartGame() {
  player = { x: window.innerWidth / 2 - 25, y: window.innerHeight - 100, health: 100, spirit: 100 };
  enemies = [];
  bullets = [];
  enemyBullets = [];
  score = 0;
  wave = 1;
  gameRunning = true;
  questionActive = false;
  currentQuestionIndex = 0;

  const battlefield = document.getElementById('battlefield');
  Array.from(battlefield.children).forEach(child => {
    if (child.id !== 'player') child.remove();
  });

  document.getElementById('game-over').style.display = 'none';
  updatePlayerPosition();
  updateUI();

  if (SND.enabled) SND.startBGM();
}

function gameLoop() {
  if (!gameRunning) { requestAnimationFrame(gameLoop); return; }
  handlePlayerMovement();
  updateEnemies();
  updateBullets();

  if (player.spirit < 100) player.spirit = Math.min(100, player.spirit + 0.2);

  updateUI();
  checkGameOver();
  requestAnimationFrame(gameLoop);
}

window.addEventListener('load', () => { initGame(); });
</script>
</body>
</html>
